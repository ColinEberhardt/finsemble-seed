{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@chartiq/fpe-router/dist/fpe-router.js","webpack:///./node_modules/es6-promise/dist/es6-promise.js","webpack:///./node_modules/process/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/finsemble-excel/commands/commands.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAK0B;AAChC,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,aAAa;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,qDAAqD;AACzE;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;;AAEA;;AAEA,sBAAsB,sBAAsB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,kDAAkD;AAClD,8DAA8D;AAC9D;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+FAA+F,kFAAkF,EAAE;;AAEnL;AACA,qGAAqG,2EAA2E,EAAE;;AAElL;AACA,uGAAuG,6EAA6E,EAAE;;;;;AAKtL;AACA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;;AAEA;;AAEA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;;AAEA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,yBAAyB;AACzB,GAAG;;;AAGH;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,6EAA6E;;AAE7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA,6CAA6C;AAC7C,8CAA8C;AAC9C;;AAEA;AACA;AACA,OAAO;;AAEP,qBAAqB,gCAAgC;AACrD;AACA,8CAA8C,wBAAwB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,8CAA8C;AAC9C,KAAK;AACL;AACA,qDAAqD;;AAErD,8EAA8E;;AAE9E,8CAA8C;AAC9C,OAAO;AACP;AACA;AACA,gDAAgD;AAChD;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,OAAO;AACP;AACA,sEAAsE;AACtE;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA,0FAA0F;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;;AAGH;AACA,uEAAuE;;AAEvE;AACA;AACA;AACA;AACA;AACA,oFAAoF;;AAEpF;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,yEAAyE;;AAEzE;AACA;AACA,8DAA8D;AAC9D,SAAS;AACT;AACA,gHAAgH;AAChH;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6DAA6D;;AAE7D;AACA;AACA,gEAAgE;AAChE,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,8DAA8D;;AAE9D;;AAEA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6EAA6E;;AAE7E;AACA;AACA,wDAAwD;AACxD,OAAO;AACP;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,sDAAsD;;AAEtD;AACA,4CAA4C;AAC5C,OAAO;AACP;AACA,kEAAkE;AAClE;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA,mDAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC,OAAO;AACP;AACA;AACA;AACA;;AAEA,4DAA4D;;AAE5D,wEAAwE,qDAAqD;AAC7H;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC,6EAA6E,6CAA6C;AACrL;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA,kEAAkE;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAA0C;AACjE;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;;AAGA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA,oFAAoF;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAA0C;AACjE;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA,aAAa,OAAO,8FAA8F;AAClH,aAAa,SAAS,6EAA6E;AACnG;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,gCAAgC;AAChC,oDAAoD;AACpD;AACA,MAAM;AACN;AACA;;;AAGA;AACA,mEAAmE;;AAEnE;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,yDAAyD,oBAAoB,GAAG,gBAAgB;AAChG;AACA;AACA;AACA;AACA,MAAM,EAAE;;;AAGR;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA,8CAA8C;AAC9C,uJAAuJ,+BAA+B;;AAEtL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6OAA6O;AAC7O;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAwC,eAAe,sCAAsC;AAClH;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,uEAAuE;AAC3F,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS,2FAA2F;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA,gEAAgE,mBAAmB;AACnF;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD;AAC/E;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,uDAAuD;;AAEvD,uDAAuD;;AAEvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+NAA+N;AAC/N;AACA,8BAA8B,iDAAiD,oFAAoF,sCAAsC;AACzM;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD,mIAAmI,iDAAiD;AACnQ;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wVAAwV;AACxV,aAAa,OAAO;AACpB;AACA;AACA;AACA;;;AAGA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;;AAEnD,uDAAuD;;AAEvD,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gGAAgG,6BAA6B,EAAE;;AAE/H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE,8BAA8B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL,4CAA4C;;AAE5C;AACA;AACA;AACA,GAAG;;AAEH;AACA,kDAAkD;AAClD;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,EAAE;AACF;AACA;;AAEA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;AAGA;AACA;AACA;AACA,wDAAwD;;AAExD,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;;AAGJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+DAA+D;;AAE/D;AACA;AACA,8DAA8D;;AAE9D;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA,OAAO;;AAEP,UAAU;AACV,CAAC;AACD,sC;;;;;;;;;;;;ACxsEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,KAA4D;AAC7D,CAAC,SAC+B;AAChC,CAAC,qBAAqB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC,yCAAyC,UAAc;AACxD;AACA,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,IAAI;AACd;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,6CAA6C;AAChE;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,MAAM;AAChB,UAAU,OAAO;AACjB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,IAAI;AACd;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,UAAU,SAAS;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,UAAU,SAAS;AACnB,UAAU,SAAS;AACnB;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,SAAS;AACnB;AACA,WAAW;AACX;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,YAAY,SAAS;AACrB,aAAa;AACb;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;AAID;;;;;;;;;;;;;ACrpCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;ACnBA;;;GAGG;;AAEH,yCAAyC;AAEzC,2HAA4C;AAE5C,IAAM,eAAe,GAAG,oBAAS,CAAC,MAAM,CAAC;AACzC,IAAM,cAAc,GAAG,oBAAS,CAAC,cAAc,CAAC;AAChD,IAAM,cAAc,GAAG,IAAI,cAAc,CAAC,eAAe,CAAC,CAAC;AAC3D,IAAI,QAAQ,GAAG,EAAE;AACjB,MAAM,CAAC,OAAO,CAAC;IACb,6CAA6C;IAC7C,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;IAC9D,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,qCAAqC,EAAE,IAAI,CAAC,CAAC;IAElF,8DAA8D;IAC9D,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC;IAE7C,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,UAAC,WAAW;QACzD,IAAI,OAAO,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC;QACpC,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;IAC7C,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH;;;GAGG;AACH,IAAM,MAAM,GAAG,UAAC,KAAiC;IAC/C,IAAM,OAAO,GAAsC;QACjD,IAAI,EAAE,MAAM,CAAC,YAAY,CAAC,2BAA2B,CAAC,oBAAoB;QAC1E,OAAO,EAAE,mBAAmB;QAC5B,IAAI,EAAE,YAAY;QAClB,UAAU,EAAE,IAAI;KACjB,CAAC;IAEF,8BAA8B;IAC9B,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAEjF,mEAAmE;IACnE,KAAK,CAAC,SAAS,EAAE,CAAC;AACpB,CAAC,CAAC;AAEF,IAAM,KAAK,GAAG,UAAC,KAAiC;IAC9C,cAAc,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IAC1C,KAAK,CAAC,SAAS,EAAE,CAAC;AACpB,CAAC,CAAC;AAEF,IAAM,aAAa,GAAG,UAAC,KAAiC;IACtD,KAAK,CAAC,GAAG,CAAC,iBAAO;QACf,IAAI,SAAS,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC;QACjE,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC7B,IAAI,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC,gBAAgB,EAAE,CAAC;QAChD,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC9B,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC;YACzB,eAAe,CAAC,QAAQ,CAAI,QAAQ,WAAQ,EAAE;gBAC5C,KAAK,EAAE,wBAAwB;gBAC/B,QAAQ,EAAE;oBACR,SAAS,EAAE,SAAS;oBACpB,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClC,MAAM,EAAE,KAAK,CAAC,MAAM;oBACpB,MAAM,EAAE,EAAC,KAAK,EAAC,MAAM,EAAC;iBACvB;gBACD,QAAQ,EAAE,QAAQ;aACnB,CAAC,CAAC;YACH,KAAK,CAAC,SAAS,EAAE,CAAC;QACpB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACxB,CAAC,CAAC;AAEF,IAAM,cAAc,GAAG,UAAC,KAAiC;IACvD,MAAM,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC;QACjC,eAAe,CAAC,QAAQ,CAAI,QAAQ,WAAQ,EAAE,EAAE,KAAK,EAAE,4BAA4B,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;QAC1G,KAAK,CAAC,SAAS,EAAE,CAAC;IACpB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,IAAM,SAAS,GAAG;IAChB,OAAO,OAAO,IAAI,KAAK,WAAW;QAChC,CAAC,CAAC,IAAI;QACN,CAAC,CAAC,OAAO,MAAM,KAAK,WAAW;YAC/B,CAAC,CAAC,MAAM;YACR,CAAC,CAAC,OAAO,MAAM,KAAK,WAAW;gBAC/B,CAAC,CAAC,MAAM;gBACR,CAAC,CAAC,SAAS,CAAC;AAChB,CAAC,CAAC;AAEF,IAAM,CAAC,GAAG,SAAS,EAAS,CAAC;AAE7B,oEAAoE;AACpE,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC;AAClB,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC;AAChB,CAAC,CAAC,aAAa,GAAG,aAAa,CAAC;AAChC,CAAC,CAAC,cAAc,GAAG,cAAc,CAAC","file":"commands.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/finsemble-excel/commands/commands.ts\");\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FpeRouter\"] = factory();\n\telse\n\t\troot[\"FpeRouter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./clientBridge/launcherClient.js\":\n/*!****************************************!*\\\n  !*** ./clientBridge/launcherClient.js ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n/**\n * @introduction\n *\n * <h2>Launcher Client</h2>\n *\n * The Launcher client handles spawning windows\n * @constructor\n * @publishedName Launcher Client\n *\n * */\nvar LauncherClient =\n/*#__PURE__*/\nfunction () {\n  function LauncherClient(routerClient) {\n    _classCallCheck(this, LauncherClient);\n\n    if (routerClient[\"default\"]) {\n      this.spawnClient = routerClient[\"default\"];\n    } else {\n      this.spawnClient = routerClient;\n    }\n  }\n  /**\n       * Spawn\n       *\n       * @param {string} component componentType of the component to spwan\n       * @param {string} parameters Finsemble component configuration parameters\n       * @param {function} callback standard callback\n       *\n       */\n\n\n  _createClass(LauncherClient, [{\n    key: \"Spawn\",\n    value: function Spawn(component, parameters, callback) {\n      if (parameters === void 0) {\n        parameters = {};\n      }\n\n      parameters[\"component\"] = component;\n      this.spawnClient.query(\"Launcher.spawn\", parameters, {}, callback);\n    }\n  }]);\n\n  return LauncherClient;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LauncherClient);\n\n/***/ }),\n\n/***/ \"./clientBridge/linkerClient.js\":\n/*!**************************************!*\\\n  !*** ./clientBridge/linkerClient.js ***!\n  \\**************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n// import e from \"express\";\n\n/**\n * ## Linker Client\n *\n *  The Linker API allows components to synchronize on a piece of data. \n *  For instance, an end user can use the Linker to link multiple components by stock symbol.\n *  Use the Linker API to enable your components to participate in this synchronization.\n *  In order for components to be linked, the components must understand the data format that will be passed between them (the \"context\"), and agree on a label that identifies that format (the dataType).\n * \n *  For instance, components might choose to publish and subscribe to a dataType called \"symbol\".\n *  They would then also need to agree what a \"symbol\" looks like, for instance, `{symbol:\"IBM\"}`. \n *  The Linker API doesn't proscribe any specific format for context or set of labels.\n *\n * @class\n */\nvar LinkerClient =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of LinkerClient.\n   * @param {RouterClient} routerClient An instance of the Router Client\n   * @memberof LinkerClient\n   */\n  function LinkerClient(routerClient) {\n    var _this = this;\n\n    _classCallCheck(this, LinkerClient);\n\n    function _uuid() {\n      var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n      var chars = CHARS,\n          uuid = new Array(36),\n          rnd = 0,\n          r;\n\n      for (var i = 0; i < 36; i++) {\n        if (i == 8 || i == 13 || i == 18 || i == 23) {\n          uuid[i] = '-';\n        } else if (i == 14) {\n          uuid[i] = '4';\n        } else {\n          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n          r = rnd & 0xf;\n          rnd = rnd >> 4;\n          uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n        }\n      }\n\n      return uuid.join('');\n    }\n\n    var uuid = _uuid();\n\n    this.routerClient = routerClient;\n    this.windowIdentifier = {\n      windowName: 'Linker Client ' + uuid,\n      uuid: uuid,\n      componentType: 'LinkerClient'\n    };\n    this.key = (this.windowIdentifier.windowName + \"::\" + this.windowIdentifier.uuid).replace(\".\", \"_\");\n    this.channelListenerList = [];\n    this.channels = [];\n    this.allChannels = [];\n    this.linkerSubscribers = {};\n    this.clients = {};\n    this.storeName = 'Finsemble_Linker';\n    var data = {\n      store: this.storeName,\n      field: \"channels\"\n    };\n    routerClient.query(\"storeService.getValue\", data, {}, function (response) {\n      if (response) {\n        _this.allChannels = response[\"data\"];\n      }\n    });\n    this.updateListeners();\n  }\n  /**\n   * @private\n   *\n   * @param {String} channel \n   * @param {Object} parameters See [Publish parameters for more detail]{@link LinkerClient#Publish}\n   * @memberof LinkerClient\n   */\n\n\n  _createClass(LinkerClient, [{\n    key: \"PublishToChannel\",\n    value: function PublishToChannel(channel, parameters) {\n      this.routerClient.transmit(channel, {\n        \"type\": parameters[\"dataType\"],\n        \"data\": parameters[\"data\"]\n      });\n    }\n    /**\n    * Publish a piece of data. \n    * Foreign components that are linked to the channels published on will receive the data if they have subscribed to this dataType.\n    * They can then use that data to synchronize their internal state.\n    * See [Subscribe]{@link LinkerClient#Subscribe} for the corresponding method.\n    * \n    *\n    * @param {Object} parameters Parameters is an object that represents the message being sent. \n    * @param {string | string[]} parameters.channels An string or string array representing a list of channels to publish on.\n    * @param {Object} parameters.data An object representing the data to send.\n    * @param {String} parameters.dataType A string representing the topic to publish on.\n    *\n    * @example\n    * let parameters = {\n    *   channels: [\"group1\"]\n    *   dataType: \"symbol\",\n    *   data: \"AAPL\"\n    * };\n    * LinkerClient.Publish(parameters);\n    *\n    */\n\n  }, {\n    key: \"Publish\",\n    value: function Publish(parameters) {\n      var _this2 = this;\n\n      var publishChannels = [];\n\n      if (parameters[\"channels\"] != null) {\n        publishChannels = parameters[\"channels\"];\n      }\n\n      if (publishChannels != null) {\n        publishChannels.forEach(function (element) {\n          _this2.PublishToChannel(element, parameters);\n        });\n      }\n    }\n    /**\n     * Register a client for a specific data type that is sent to a channel. Calling `subscribe` multiple times add additional handlers.\n     *\n     * @param {String} dataType A string representing the data type to subscribe to.\n     * @param {Function} callback A function to be called once the Linker receives the specific data.\n     * @memberof LinkerClient\n     * \n     * @example\n     * \n     * LinkerClient.Subscribe(\"symbol\", function(data) {\n     *  //console.log(\"New symbol received from a remote component: \", data);\n     * });\n     * \n     */\n\n  }, {\n    key: \"Subscribe\",\n    value: function Subscribe(dataType, callback) {\n      if (dataType in this.linkerSubscribers) {\n        this.linkerSubscribers[dataType] += callback;\n      } else {\n        this.linkerSubscribers[dataType] = callback;\n      }\n\n      this.updateListeners();\n    }\n    /**\n     * @private\n     *\n     * @param {Error} err If not null, an error explaining what went wrong\n     * @param {*} data \n     * @memberof LinkerClient\n     */\n\n  }, {\n    key: \"handleListeners\",\n    value: function handleListeners(err, data) {\n      if (err) {\n        console.error(err);\n      }\n\n      //console.log('handleListeners fired');\n      var listeners = this.linkerSubscribers[data.data.type];\n\n      if (listeners && listeners.length > 0) {\n        for (var i = 0; i < listeners.length; i++) {\n          listeners[i](data.data.data, {\n            data: data.data.data,\n            header: data.header,\n            originatedHere: data.originatedHere\n          });\n        }\n      }\n    }\n    /**\n     * @private\n     *\n     * @memberof LinkerClient\n     */\n\n  }, {\n    key: \"updateListeners\",\n    value: function updateListeners() {\n      var _this3 = this;\n\n      //console.log('updateListeners fired');\n\n      var _loop = function _loop(i) {\n        var channel = _this3.channelListenerList[i];\n        var channels = Object.keys(_this3.channels);\n\n        if (!channels.filter(function (g) {\n          return g == channel;\n        }).length) {\n          _this3.routerClient.removeListener(channel, _this3.handleListeners);\n\n          _this3.channelListenerList.splice(i, 1);\n        }\n      };\n\n      for (var i = this.channelListenerList.length - 1; i >= 0; i--) {\n        _loop(i);\n      }\n\n      var channels = Object.keys(this.channels);\n\n      for (var _i = 0; _i < channels.length; _i++) {\n        var channel = channels[_i];\n\n        if (!this.channelListenerList.includes(channel)) {\n          this.routerClient.addListener(channel, this.handleListeners);\n          this.channelListenerList.push(channel);\n        }\n      }\n    }\n    /**\n     * Add a component to a Linker channel programmatically. \n     * Components will begin receiving any new contexts published to this channel but will **not** receive the currently established context.\n     *\n     * @param {(String | String[])} channel The name of the channel, or channels, to link our component to.\n     * @param {WindowIdentifier} [windowIdentifier] windowIdentifier for the component. If null, it defaults to the current window.\n     * @param {Function} [callback] Callback to retrieve returned results asynchronously.\n     * @memberof LinkerClient\n     * \n     * @example\n     * \n     * LinkerClient.LinkToChannel(\"group3\", null); // Linker current window to channel\n     * LinkerClient.LinkToChannel(\"group3\", windowIdentifier); // Link the requested window to channel\n     */\n\n  }, {\n    key: \"LinkToChannel\",\n    value: function LinkToChannel(channel, windowIdentifier, callback) {\n      function makeKey(windowIdentifier) {\n        return (windowIdentifier[\"windowName\"] + \"::\" + windowIdentifier[\"uuid\"]).replace(\".\", \"_\");\n      }\n\n      var _windowIdentifier;\n\n      var keyToUse = this.key;\n\n      if (!windowIdentifier) {\n        _windowIdentifier = this.windowIdentifier;\n      } else {\n        _windowIdentifier = windowIdentifier;\n        keyToUse = makeKey(windowIdentifier);\n      }\n\n      if (!this.clients[keyToUse]) {\n        this.clients[keyToUse] = {\n          client: _windowIdentifier,\n          channels: []\n        };\n      }\n\n      this.clients[keyToUse][\"channels\"][channel] = true;\n      var data = {\n        store: this.storeName,\n        field: 'clients.' + keyToUse,\n        value: this.clients[keyToUse]\n      };\n      //console.log(data);\n      this.routerClient.query(\"storeService.setValue\", data, {}, function (resp) {\n        //console.log(resp);\n      });\n      this.updateListeners();\n    }\n  }]);\n\n  return LinkerClient;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinkerClient);\n\n/***/ }),\n\n/***/ \"./index.js\":\n/*!******************!*\\\n  !*** ./index.js ***!\n  \\******************/\n/*! exports provided: default, router, LinkerClient, LauncherClient */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _routerClient_routerClientInstance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./routerClient/routerClientInstance */ \"./routerClient/routerClientInstance.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"router\", function() { return _routerClient_routerClientInstance__WEBPACK_IMPORTED_MODULE_0__[\"router\"]; });\n\n/* harmony import */ var _clientBridge_linkerClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clientBridge/linkerClient */ \"./clientBridge/linkerClient.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LinkerClient\", function() { return _clientBridge_linkerClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _clientBridge_launcherClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clientBridge/launcherClient */ \"./clientBridge/launcherClient.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LauncherClient\", function() { return _clientBridge_launcherClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  router: _routerClient_routerClientInstance__WEBPACK_IMPORTED_MODULE_0__[\"router\"],\n  LinkerClient: _clientBridge_linkerClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  LauncherClient: _clientBridge_launcherClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n});\n\n\n/***/ }),\n\n/***/ \"./routerClient/routerClientConstructor.js\":\n/*!*************************************************!*\\\n  !*** ./routerClient/routerClientConstructor.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexports.__esModule = true;\n\nvar routerTransport_1 = __webpack_require__(/*! ./routerTransport */ \"./routerClient/routerTransport.js\");\n\nvar queue = []; // should never be used, but message sent before router ready will be queue\n\n/**\n *\n * ## Router Client\n *\n * The Router Client sends and receives event messages between Finsemble components and services. See the <a href=tutorial-TheRouter.html>Router tutorial</a> for an overview of the Router's functionality.\n *\n * Router callbacks for incoming messages are **always** in the form `callback(error, event)`. If `error` is null, then the incoming data is always in `event.data`. If `error` is set, it contains a diagnostic object and message. On error, the `event` parameter is not undefined.\n *\n *\n * @constructor\n * @hideconstructor\n * @publishedName RouterClient\n * @param {string} clientName Router base client name for human readable messages (window name is concatenated to baseClientName)\n * @param {string=} transportName Router transport name, always \"SharedWorker\"\n */\n\nexports.RouterClientConstructor = function (params) {\n  var _this = this; ///////////////////////////\n  // Private Data\n  ///////////////////////////\n\n\n  var baseClientName = params.clientName;\n  var transportName = params.transportName;\n  var handshakeHandler;\n  var timeCalibrationHandler;\n  var mapListeners = {};\n  var mapResponders = {};\n  var mapPubSubResponders = {};\n  var mapPubSubResponderState = {};\n  var mapPubSubResponderRegEx = {};\n  var pubsubListOfSubscribers = {};\n  var mapSubscribersID = {};\n  var mapSubscribersTopic = {};\n  var mapQueryResponses = {};\n  var mapQueryResponseTimeOut = {};\n  var clientName;\n  var transport = null;\n  var isRouterReady = false;\n  var parentReadyCallbackQueue = []; // must be queue because may be multiple waiters\n\n  var self = this;\n  this.startupTime = 0;\n  var UUID = create_UUID(); /////////////////////////////////////////////////////////////////////\n  // Private Message Contructors for Communicating with RouterService\n  /////////////////////////////////////////////////////////////////////\n\n  function InitialHandshakeMessage() {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"initialHandshake\"\n    };\n  }\n\n  function TimeCalibrationHandshakeMessage(clientBaseTime, serviceBaseTime) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"timeCalibration\"\n    };\n    this.clientBaseTime = clientBaseTime;\n    this.serviceBaseTime = serviceBaseTime;\n  }\n\n  function AddListenerMessage(channel) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"addListener\",\n      \"channel\": channel\n    };\n  }\n\n  function TransmitMessage(toChannel, data, options) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"transmit\",\n      \"channel\": toChannel\n    };\n    this.data = data;\n    this.options = options;\n  }\n\n  function RemoveListenerMessage(channel) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"removeListener\",\n      \"channel\": channel\n    };\n  }\n\n  function addResponderMessage(channel) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"addResponder\",\n      \"channel\": channel\n    };\n  }\n\n  function QueryMessage(queryID, channel, data) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"query\",\n      \"queryID\": queryID,\n      \"channel\": channel\n    };\n    this.data = data;\n  }\n\n  function QueryResponseMessage(queryID, error, data) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"queryResponse\",\n      \"queryID\": queryID,\n      \"error\": error\n    };\n    this.data = data;\n  }\n\n  function RemoveResponderMessage(channel) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"removeResponder\",\n      \"channel\": channel\n    };\n  }\n\n  function SubscribeMessage(subscribeID, topic) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"subscribe\",\n      \"subscribeID\": subscribeID,\n      \"topic\": topic\n    };\n  }\n\n  function UnsubscribeMessage(subscribeID, topic) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"unsubscribe\",\n      \"subscribeID\": subscribeID,\n      \"topic\": topic\n    };\n  }\n\n  function PublishMessage(topic, data) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"publish\",\n      \"topic\": topic\n    };\n    this.data = data;\n  }\n\n  function NotifyMessage(subscribeID, topic, error, data) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"notify\",\n      \"subscribeID\": subscribeID,\n      \"topic\": topic,\n      \"error\": error\n    };\n    this.data = data;\n  }\n\n  function AddPubSubResponderMessage(topic) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"addPubSubResponder\",\n      \"topic\": topic\n    };\n  }\n\n  function RemovePubSubResponderMessage(topic) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"removePubSubResponder\",\n      \"topic\": topic\n    };\n  }\n\n  function JoinGroupMessage(group) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"joinGroup\",\n      \"group\": group\n    };\n  }\n\n  function LeaveGroupMessage(group) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"leaveGroup\",\n      \"group\": group\n    };\n  }\n\n  function GroupTransmitMessage(group, toChannel, message, data) {\n    this.header = {\n      \"origin\": clientName,\n      \"type\": \"groupTransmit\",\n      \"group\": group,\n      \"channel\": toChannel\n    };\n    this.data = data;\n  } //////////////////////\n  // Private Functions\n  //////////////////////\n  // router client is being terminated so cleanup\n\n\n  function destructor(event) {\n    //console.log(\"WINDOW LIFECYCLE:Shutdown:RouterClient:Shutting down.\");\n    self.disconnectAll(); // this will let the router know the client is terminating\n  } // invoked when router init is complete\n\n\n  function onReadyCallBack() {\n    // self.startupTime = performance.now() - self.startupTime;\n    //console.log(\"WINDOW LIFECYCLE:STARTUP:RouterClient Ready\");\n    isRouterReady = true; // invoke all the parent callbacks waiting for router to be ready\n\n    while (parentReadyCallbackQueue.length > 0) {\n      //console.log(\"WINDOW LIFECYCLE:STARTUP:RouterClient parentReady invoked\");\n      var nextParentCallback = parentReadyCallbackQueue.shift();\n      nextParentCallback();\n    }\n  } // called once on router-client creation\n\n\n  function constructor(clientName, transportName) {\n    //console.log(\"WINDOW LIFECYCLE:STARTUP:RouterClient Constructor:Name:\", clientName);\n\n    function processManifest() {\n      //console.log(\"WINDOW LIFECYCLE:STARTUP:RouterClient:processManifest\"); //If manifest is a string, then there was an error getting the manifest because in a separate application\n\n      asyncConnectToEventRouter(clientName, transportName, onReadyCallBack);\n      /**** establish connection to router service ****/\n    }\n\n    processManifest();\n  }\n\n  function create_UUID() {\n    var dt = new Date().getTime();\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (dt + Math.random() * 16) % 16 | 0;\n      dt = Math.floor(dt / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n    return uuid;\n  } // connects to event-router service. will retry various ways if needed\n\n\n  function asyncConnectToEventRouter(clientName, transportName, onReadyCallBack) {\n    var myTimer;\n    var myRetryCounter;\n    var isFinished = false;\n    var handshakeFailedCount = 0;\n    var routerParams = {\n      FinsembleUUID: UUID,\n      applicationRoot: \"ws://127.0.0.1:3376\",\n      routerDomainRoot: \"localhost\",\n      forceWindowTransport: {},\n      sameDomainTransport: \"SharedWorker\",\n      crossDomainTransport: \"FinsembleTransport\",\n      transportSettings: {},\n      IAC: {}\n    };\n\n    function getClientTransport() {\n      transport = routerTransport_1[\"default\"].getTransport(routerParams, transportName, incomingMessageHandler, clientName, \"RouterService\").then(transportReady)[\"catch\"](errHandler);\n    }\n\n    function transportReady(transportObj) {\n      myRetryCounter = 0;\n      transport = transportObj;\n      handshakeHandler = finished; // set function to receive handshake response\n\n      sendHandshake();\n      myTimer = setInterval(sendHandshake, 200); // start time to retry if response not recieved back from router service\n    }\n\n    function handshakeFailedHandler() {\n      clearInterval(myTimer);\n      handshakeFailedCount++;\n\n      if (handshakeFailedCount <= 3) {\n        getClientTransport();\n      } else {\n        console.warn(\"error connecting to the transport\");\n      }\n    }\n\n    function sendHandshake() {\n      sendToRouterService(new InitialHandshakeMessage());\n\n      if (myRetryCounter++ > 50) {\n        handshakeFailedHandler();\n      }\n    }\n\n    function finished() {\n      if (!isFinished) {\n        // ensure only invoked once\n        isFinished = true;\n        clearInterval(myTimer);\n\n        if (queue) {\n          // this should not happen with proper startup order, which waits on routerClient to be ready\n          for (var i = 0; i < queue.length; i++) {\n            var msg = queue[i];\n            transport.send(msg);\n          }\n        } // notify initialization is complete\n\n\n        if (onReadyCallBack) {\n          onReadyCallBack();\n        }\n      }\n    }\n\n    function errHandler(errorMessage) {\n      //console.log(\"RouterClientError\", errorMessage);\n    } // main code for this asyncConnectToEventRouter function -- only executed once\n\n\n    getClientTransport();\n  } // provides unique id within one router client for queries\n\n\n  function clientID() {\n    return clientName + \".\" + UUID;\n  } // returns true if this routerClient originated the message\n\n\n  function originatedHere() {\n    return this.header.origin === this.header.lastClient;\n  } // invoke client callbacks in the input array (that are attached to a specific channel and listener type)\n\n\n  function invokeListenerCallbacks(map, message) {\n    var originalClientCallbackArray = map[message.header.channel] || [];\n    var clientCallbackArray = [];\n\n    if (clientCallbackArray === undefined) {} else {\n      message.originatedHere = originatedHere; // add local function to test origin\n      //@note, have to operate off of a copy because a callback may call removeListener, which will modify map[message.header.channel].\n\n      originalClientCallbackArray.forEach(function (cb) {\n        clientCallbackArray.push(cb);\n      });\n\n      for (var i = 0; i < clientCallbackArray.length; i++) {\n        // for each callback defined for the channel\n        clientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\n      }\n    }\n  }\n\n  function sendQueryResponse(err, responseData) {\n    //@todo consider removing this log. Why log it? Why not log it _only_ if the dev wants a particular message logged. This can cause problems.\n    sendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\n  } // invoke responder-listener callback (attached to a specific channel)\n\n\n  function invokeResponderCallback(map, queryMessage) {\n    var responderCallback = map[queryMessage.header.channel];\n\n    if (responderCallback === undefined) {\n      //responderCallback(null, queryMessage); // invoke the callback (no error), queryMessage);\n    } else {\n      if (!queryMessage.header.error) {\n        queryMessage.originatedHere = originatedHere; // add local function to test origin\n\n        queryMessage.sendQueryResponse = sendQueryResponse.bind(queryMessage); // add callback function to message so responder can respond to query\n\n        responderCallback(null, queryMessage); // invoke the callback (no error)\n      } else {\n        // invoke the callback with error since  flag in message (from router service)\n        responderCallback(queryMessage.header.error, null);\n        delete map[queryMessage.header.channel]; // this is a bad responder (e.g. duplicate) so remove it\n      }\n    }\n  } // add a callbackHandler into the query-response map for the given queryID\n\n\n  function addQueryResponseCallBack(map, queryID, responseCallback) {\n    map[queryID] = responseCallback;\n  } // add timer to wait for query response\n\n\n  function addQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, channel, timeout) {\n    if (timeout > 0) {\n      mapQueryResponseTimeOut[newQueryID] = setTimeout(function () {\n        ////console.log(\"RouterClient: timeout waiting on query response on channel \" + channel + \" for queryID \" + newQueryID + \" on timer \" + mapQueryResponseTimeOut[newQueryID] + \" timeout=\" + timeout);\n      }, timeout);\n    }\n  } // delete timer waiting on query response (if it exists)\n\n\n  function deleteQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID) {\n    var theTimer = mapQueryResponseTimeOut[newQueryID];\n\n    if (theTimer !== undefined) {\n      clearTimeout(theTimer);\n    }\n  } // invoke query-response callback (that is attached to a specific channel and listener type)\n\n\n  function invokeQueryResponseCallback(map, responseMessage) {\n    var clientCallback = map[responseMessage.header.queryID];\n\n    if (clientCallback === undefined) {\n      ////console.log(\"RouterClient: no handler for incoming query response\", \"QUERY ID\", responseMessage.header.queryID);\n    } else {\n      // delete any existing timer waiting on the response\n      deleteQueryResponseTimeout(mapQueryResponseTimeOut, responseMessage.header.queryID);\n\n      if (!responseMessage.header.error) {\n        //@todo consider removing this log. Why log it? Why not log it _only_ if the dev wants a particular message logged. This can cause problems.\n        //////console.log(\"RouterClient: incoming query response\", \"RESPONSE MESSAGE\", responseMessage, \"QUERY ID\", responseMessage.header.queryID);\n        clientCallback(null, responseMessage); // invoke the callback passing the response message\n      } else {\n        ////console.log(\"RouterClient: incoming queryResponse error\", responseMessage.header, \"QUERY ID\", responseMessage.header.queryID);\n        clientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\n      }\n\n      delete map[responseMessage.header.queryID];\n    }\n  } // add responder callbackHandler for the given channel\n\n\n  function addResponderCallBack(map, channel, callback) {\n    var status = false;\n    var clientCallback = map[channel];\n\n    if (clientCallback === undefined) {\n      map[channel] = callback;\n      status = true;\n    }\n\n    return status;\n  } // support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub responder\n\n\n  function addToPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n    if (!(topic in pubsubListOfSubscribers)) {\n      pubsubListOfSubscribers[topic] = [subscribeID];\n    } else {\n      pubsubListOfSubscribers[topic].push(subscribeID);\n    }\n  } // support function for addPubSubResponder -- add pubsub responder callbackHandler for the given channel\n\n\n  function addPubSubResponderCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\n    var status = false;\n    var callbacks = mapPubSubResponders[topic.toString()];\n\n    if (callbacks === undefined) {\n      if (topic instanceof RegExp) {\n        mapPubSubResponderRegEx[topic.toString()] = topic;\n        ////console.log(\"RouterClient: PubSub RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\n      }\n\n      mapPubSubResponders[topic.toString()] = {\n        \"subscribeCallback\": subscribeCallback,\n        \"publishCallback\": publishCallback,\n        \"unsubscribeCallback\": unsubscribeCallback\n      };\n      status = true;\n    }\n\n    return status;\n  } // callback function for invokeSubscribePubSubCallback to notify new subscriber\n\n\n  function sendNotifyToSubscriber(err, notifyData) {\n    //@todo consider removing this log. Why log it? Why not log it _only_ if the dev wants a particular message logged. This can cause problems.\n    sendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\n\n    if (!err) {\n      // add new subscriber to list\n      addToPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n      ////console.log(\"RouterClient: incoming subscription added\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n    } else {\n      ////console.log(\"RouterClient: incoming subscription rejected by pubsub responder\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n    }\n  } // for incoming subscribe: invoke notify callback for pubsub responder\n\n\n  function invokeSubscribePubSubCallback(subscribeMessage) {\n    var callbacks = mapPubSubResponders[subscribeMessage.header.topic]; //@todo consider removing this log. Why log it? Why not log it _onlY_ if the dev wants a particular message logged. This can cause problems.\n\n    if (callbacks === undefined) {\n      // if undefined then may be a matching RegEx topic\n      for (var key in mapPubSubResponderRegEx) {\n        if (mapPubSubResponderRegEx[key].test(subscribeMessage.header.topic)) {\n          callbacks = mapPubSubResponders[key];\n          var initialState = mapPubSubResponderState[subscribeMessage.header.topic]; // may already be initial state defined from publish\n\n          if (initialState === undefined) {\n            // if there isn't already state defined then use default from regEx\n            initialState = mapPubSubResponderState[key]; // initialize the state from RegEx topic\n          }\n\n          mapPubSubResponderState[subscribeMessage.header.topic] = initialState;\n          break;\n        }\n      }\n    }\n\n    if (callbacks === undefined) {\n      // if still undefined\n      ////console.log(\"RouterClient: no pubsub responder defined for incoming subscribe\", subscribeMessage);\n    } else {\n      if (subscribeMessage.header.error) {\n        // the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\n        ////console.log(\"RouterClient: pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\n      } else {\n        subscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub responder can respond with Notify message\n\n        if (callbacks.subscribeCallback) {\n          subscribeMessage.data = mapPubSubResponderState[subscribeMessage.header.topic];\n          callbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\n        } else {\n          // since no subscribe callback defined, use default functionality\n          subscribeMessage.sendNotifyToSubscriber(null, mapPubSubResponderState[subscribeMessage.header.topic]); // must invoke from message to set this properly\n        }\n      }\n    }\n  } // support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\n\n\n  function removeFromPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n    var removed = false;\n\n    if (topic in pubsubListOfSubscribers) {\n      var list = pubsubListOfSubscribers[topic];\n\n      for (var i = 0; i < list.length; i++) {\n        if (subscribeID === list[i]) {\n          list.splice(i, 1);\n\n          if (list.length === 0) {\n            delete pubsubListOfSubscribers[topic];\n          }\n\n          removed = true;\n          ////console.log(\"RouterClient: PubSub removeListener\", \"TOPIC\", topic, \"FROM\", subscribeID);\n          break;\n        }\n      }\n    }\n\n    if (!removed) {\n      //console.log(\"RouterClient: tried to remove non-existant listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\n    }\n  } // callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\n\n\n  function removeSubscriber() {\n    removeFromPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n  } // for incoming unsubscribe: invoke unsubscribe callback for pubsub service\n\n\n  function invokeUnsubscribePubSubCallback(unsubscribeMessage) {\n    var callbacks = mapPubSubResponders[unsubscribeMessage.header.topic];\n\n    if (callbacks === undefined) {\n      // if undefined then may be a matching RegEx topic\n      for (var key in mapPubSubResponderRegEx) {\n        if (mapPubSubResponderRegEx[key].test(unsubscribeMessage.header.topic)) {\n          callbacks = mapPubSubResponders[key];\n          break;\n        }\n      }\n    }\n\n    if (callbacks === undefined) {\n      // if still undefined\n      //console.log(\"RouterClient: no pubsub responder defined for incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n    } else {\n      unsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub responder (but must always remove)\n\n      if (callbacks.unsubscribeCallback) {\n        //console.log(\"RouterClient: incoming unsubscribe callback\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n        callbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\n      } else {\n        // since no unsubscribe callback defined, use default functionality\n        //console.log(\"RouterClient: incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n        unsubscribeMessage.removeSubscriber();\n      }\n    }\n  } // callback function for invokePublishPubSubCallback to send Notify\n\n\n  function sendNotifyToAllSubscribers(err, notifyData) {\n    if (!err) {\n      mapPubSubResponderState[this.header.topic] = notifyData; // store new state\n\n      var listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\n\n      if (typeof listOfSubscribers !== \"undefined\") {\n        // confirm subscribers to send to, if none then nothing to do\n        for (var i = 0; i < listOfSubscribers.length; i++) {\n          //console.log(\"RouterClient: sending pubsub notify\", \"TOPIC\", this.header.topic, \"NOTIFY DATA\", notifyData);\n          sendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\n        }\n      }\n    } else {\n      //console.log(\"RouterClient: income publish rejected by pubsub responder\", err, notifyData);\n    }\n  } // for incoming Publish: invoke publish callback for pubsub service\n\n\n  function invokePublishPubSubCallback(publishMessage) {\n    var callbacks = mapPubSubResponders[publishMessage.header.topic];\n\n    if (callbacks === undefined) {\n      // if undefined then may be a matching RegEx topic\n      for (var key in mapPubSubResponderRegEx) {\n        if (mapPubSubResponderRegEx[key].test(publishMessage.header.topic)) {\n          callbacks = mapPubSubResponders[key];\n          break;\n        }\n      }\n    }\n\n    if (callbacks === undefined) {\n      // if still undefined\n      //console.log(\"RouterClient: no pubsub responder defined for incoming publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n    } else {\n      publishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub responder can respond to publish\n\n      if (callbacks.publishCallback) {\n        //console.log(\"RouterClient: incoming PubSub publish callback invoked\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n        callbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\n      } else {\n        // since no pubish callback defined, use default functionality\n        //console.log(\"RouterClient: incoming PubSub publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n        publishMessage.sendNotifyToAllSubscribers(null, publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\n      }\n    }\n  } // for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type)\n\n\n  function invokeNotifyCallback(mapSubscribersID, notifyMessage) {\n    var notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\n\n    if (notifyCallback === undefined) {\n      //console.log(\"RouterClient: no subscription handler defined for incoming notify for subscriberID\", notifyMessage.header.subscribeID, notifyMessage);\n    } else {\n      if (!notifyMessage.header.error) {\n        notifyMessage.originatedHere = originatedHere; // add local function to test origin\n\n        //console.log(\"RouterClient: incoming PubSub notify\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n        notifyCallback(null, notifyMessage); // invoke the callback passing the response message\n      } else {\n        //console.log(\"RouterClient: incoming PubSub notify error for subscriberID\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n        notifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\n      }\n    }\n  } // outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\n\n\n  function removeSubscriberCallBack(mapSubscribersID, subscribeID) {\n    var status = false;\n    var notifyCallback = mapSubscribersID[subscribeID];\n\n    if (notifyCallback !== undefined) {\n      delete mapSubscribersID[subscribeID];\n      status = true;\n    }\n\n    return status;\n  } // for outgoing addSubscriber -- add a callback Handler for the subscribe\n\n\n  function addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\n    mapSubscribersID[subscribeID] = notifyCallback;\n    mapSubscribersTopic[subscribeID] = topic;\n  } // for removePubSubResponder: remove responder callbackHandler for the given channel\n\n\n  function removeResponderCallBack(map, channel) {\n    var status = false;\n    var clientCallback = map[channel];\n\n    if (clientCallback !== undefined) {\n      delete map[channel];\n      status = true;\n    }\n\n    return status;\n  } // for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\n\n\n  function addListenerCallBack(map, channel, callback) {\n    var firstChannelClient = false;\n    var clientCallbackArray = map[channel];\n\n    if (clientCallbackArray === undefined || clientCallbackArray.length === 0) {\n      map[channel] = [callback];\n      firstChannelClient = true;\n    } else {\n      clientCallbackArray.push(callback);\n    }\n\n    return firstChannelClient;\n  } // for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\n\n\n  function removeListenerCallBack(map, channel, callback) {\n    var lastChannelClient = false;\n    var clientCallbackArray = map[channel];\n\n    if (clientCallbackArray !== undefined) {\n      var index = clientCallbackArray.indexOf(callback);\n\n      if (index > -1) {\n        clientCallbackArray.splice(index, 1);\n\n        if (clientCallbackArray.length === 0) {\n          lastChannelClient = true;\n        }\n      } else {\n        //console.log(\"no listener defined for channel: \" + channel);\n      }\n    }\n\n    return lastChannelClient;\n  } // route incoming message to appropriate callback, which depends on the message type and channel\n\n\n  function routeIncomingMessage(incomingMessage) {\n    //console.log(\"Incoming Message Type\", incomingMessage.header.type, incomingMessage);\n\n    switch (incomingMessage.header.type) {\n      case \"transmit\":\n        invokeListenerCallbacks(mapListeners, incomingMessage);\n        break;\n\n      case \"query\":\n        invokeResponderCallback(mapResponders, incomingMessage);\n        break;\n\n      case \"queryResponse\":\n        invokeQueryResponseCallback(mapQueryResponses, incomingMessage);\n        break;\n\n      case \"notify\":\n        invokeNotifyCallback(mapSubscribersID, incomingMessage);\n        break;\n\n      case \"publish\":\n        invokePublishPubSubCallback(incomingMessage);\n        break;\n\n      case \"subscribe\":\n        invokeSubscribePubSubCallback(incomingMessage);\n        break;\n\n      case \"unsubscribe\":\n        invokeUnsubscribePubSubCallback(incomingMessage);\n        break;\n\n      case \"timeCalibration\":\n        timeCalibrationHandler(incomingMessage);\n        break;\n\n      case \"initialHandshakeResponse\":\n        handshakeHandler();\n        break;\n\n      default:\n    }\n  }\n\n  function clone(from, to) {\n    if (from === null || _typeof(from) !== \"object\") {\n      return from;\n    } // if (from.constructor != Object && from.constructor != Array) return from;\n\n\n    if (from.constructor == Date || from.constructor == RegExp || from.constructor == Function || from.constructor == String || from.constructor == Number || from.constructor == Boolean) {\n      return new from.constructor(from);\n    }\n\n    to = to || new from.constructor();\n\n    for (var n in from) {\n      to[n] = typeof to[n] === \"undefined\" ? clone(from[n], null) : to[n];\n    }\n\n    return to;\n  } // *** all incoming messages from underlying transport arrive here ***\n  // although incoming transport information is available, it is not passed on because not needed\n\n\n  function incomingMessageHandler(incomingTransportInfo, message) {\n    // ToDo: good place to put a function to validate incoming message/data\n    message.header.lastClient = clientName; // add last client for diagnostics\n\n    message.header.incomingTransportInfo = incomingTransportInfo;\n    routeIncomingMessage(message);\n  } // *** all outbound messages exit here though the appropriate transport ***\n\n\n  function sendToRouterService(message) {\n    if (!transport || transport instanceof Promise) {\n      //console.log(\"RouterClient: Queuing message since router initialization not complete\", message);\n      queue.push(message);\n    } else {\n      transport.send(message);\n    }\n  }\n  /**\n   * Estimates offset to align the reference time with Router Service.  Does this by exchanging messages with RouterService, getting the service's time, and estimating communication delay.\n   *\n   * @private\n   */\n\n\n  this.calibrateTimeWithRouterService = function (callback) {\n    var TARGET_HANDSHAKE_COUNT = 5;\n    var handshakeCounter = 0;\n    var timeOffset;\n    var offsetForFastest;\n    var fastestRRT = Infinity;\n\n    function calibrationCalculation(finalHandshakeMessage) {\n      var timeOffset = 0;\n\n      for (var i = 1; i < TARGET_HANDSHAKE_COUNT; i++) {\n        var startClientTime = finalHandshakeMessage.clientBaseTime[i - 1];\n        var stopClientTime = finalHandshakeMessage.clientBaseTime[i];\n        var rtt = stopClientTime - startClientTime; // round-trip time\n\n        var serviceTime = finalHandshakeMessage.serviceBaseTime[i - 1];\n        var offset = serviceTime - (startClientTime + rtt / 2);\n\n        if (rtt < fastestRRT) {\n          fastestRRT = rtt;\n          offsetForFastest = offset;\n        }\n\n        timeOffset += offset;\n        //console.log(\"calibrationCalculation Intermediate Values\", \"lastRRT\", rtt, \"lastOffset\", offset, \"fastestOffset\", offsetForFastest, \"fastestRRT\", fastestRRT);\n      }\n\n      timeOffset /= TARGET_HANDSHAKE_COUNT - 1;\n      //console.log(\"RouterClient calibrationCalculation\", \"Average Offset\", timeOffset, \"Chosen FastestOffset\", offsetForFastest, finalHandshakeMessage);\n      callback(offsetForFastest); // use the offset with the shortest RTT since it is often the most accurate\n    }\n\n    function timeCalibrationHandlerFunction(message) {\n      handshakeCounter++;\n\n      if (handshakeCounter > TARGET_HANDSHAKE_COUNT) {\n        calibrationCalculation(message); // enough handshake data gather, so do the calibration\n      } else {\n        // message.clientBaseTime.push(window.performance.timing.navigationStart + window.performance.now());\n        sendToRouterService(new TimeCalibrationHandshakeMessage(message.clientBaseTime, message.serviceBaseTime));\n      }\n    }\n\n    timeCalibrationHandler = timeCalibrationHandlerFunction; // used in routeIncomingMessage to route handshake response back to handler\n\n    timeCalibrationHandler(new TimeCalibrationHandshakeMessage([], [])); // invoke first time to start exchanging handshakes; will be invoked each time handshake message received back from FouterService\n  };\n  /**\n   * Backward compatibility?\n   * @private\n   */\n\n\n  this.ready = function (cb) {\n    return _this.onReady(cb);\n  };\n  /**\n  * Get router client name.\n  *\n  * @param {string} newClientName string identify the client\n  * FSBL.Clients.RouterClient.setClientName(\"MyComponent\");\n  * @private\n  */\n\n\n  this.getClientName = function () {\n    //console.log(\"RouterClient.getClientName\", clientName);\n    return clientName;\n  }; /////////////////////////////////////////////\n  // Public Functions -- The Router Client API\n  /////////////////////////////////////////////\n\n  /**\n   * Checks if router is ready. May be invoked multiple times. Invokes cb when ready, which may be immediately.  Router is not ready until underlying transport to router service is ready.\n   *\n   * @param {function} cb callback function to invoke when router is ready\n   */\n\n\n  this.onReady = function (cb) {\n    // Validate.args(cb, \"function\");\n    if (isRouterReady) {\n      cb();\n    } else {\n      parentReadyCallbackQueue.push(cb);\n    }\n  };\n  /**\n   * Add listener for incoming transmit events on specified channel. Each of the incoming events will trigger the specified event handler. The number of listeners is not limited (either local to this Finsemble window or in a separate Finsemble window).\n   *\n   * See [transmit]{@link RouterClientConstructor#transmit} for sending a corresponding event message to listener. See [removeListener]{@link RouterClientConstructor#removeListener} to remove the listener.\n   *\n   * @param {string} channel any unique string to identify the channel (must match correspond transmit channel name)\n   * @param {function} eventHandler function (see example below)\n   * @example\n   *\n   * FSBL.Clients.RouterClient.addListener(\"SomeChannelName\", function (error, response) {\n   * \tif (error) {\n   *\t\t\t//console.log(\"ChannelA Error: \" + JSON.stringify(error));\n   *\t\t} else {\n   *\t\t\tvar data = response.data;\n   *\t\t\t//console.log(\"ChannelA Response: \" + JSON.stringify(response));\n   *\t\t}\n   * });\n   *\n   */\n\n\n  this.addListener = function (channel, eventHandler) {\n    //console.log(\"RouterClient.addListener\", \"CHANNEL\", channel); // Validate.args(channel, \"string\", eventHandler, \"function\");\n\n    var firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\n\n    if (firstChannelClient) {\n      sendToRouterService(new AddListenerMessage(channel));\n    }\n  };\n  /**\n   * Transmit event to all listeners on the specified channel. If no listeners the event is discarded without error. All listeners to the channel in this Finsemble window and other Finsemble windows will receive the transmit.\n   *\n   * See [addListener]{@link RouterClientConstructor#addListener} to add a listener to receive the transmit.\n   *\n   * @param {string} toChannel any unique string to identify the channel (must match correspond listener channel name)\n   * @param {any} event any object or primitive type to be transmitted\n   * @param {object} [options] Options object for your transmit\n   * @param {boolean} [options.suppressWarnings=false] By default, the Router will log warnings if you transmit to a channel with no listeners. Set this to true to eliminate those warnings.\n   * @example\n   *\n   * FSBL.Clients.RouterClient.transmit(\"SomeChannelName\", event);\n   *\n   */\n\n\n  this.transmit = function (toChannel, event, options) {\n    // if (!Logger.isLogMessage(toChannel)) { // logger messages\n    if (options === void 0) {\n      options = {\n        suppressWarnings: false\n      };\n    }\n\n    //console.log(\"RouterClient.transmit\", \"TO CHANNEL\", toChannel, \"EVENT\", event); // }\n    // Validate.args(toChannel, \"string\", event, \"any\");\n\n    sendToRouterService(new TransmitMessage(toChannel, event, options));\n  };\n  /**\n   * Remove event listener from specified channel for the specific event handler (only listeners created locally can be removed).\n   *\n   * See [addListener]{@link RouterClientConstructor#addListener} for corresponding add of a listener.\n   *\n   * @param {string} channel unique channel name to remove listener from\n   * @param {function} eventHandler function used for the event handler when the listener was added\n   */\n\n\n  this.removeListener = function (channel, eventHandler) {\n    //console.log(\"RouterClient.removelistener\", \"CHANNEL\", channel, \"EVENT HANDLER\", eventHandler);\n    var lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\n\n    if (lastChannelListener) {\n      sendToRouterService(new RemoveListenerMessage(channel));\n    }\n  };\n  /**\n   * Add a query responder to the specified channel. The responder's queryEventHander function will receive all incoming queries for the specified channel (whether from this Finsemble window or remote Finsemble windows).\n   *\n   * *Note:* Only one responder is allowed per channel within the Finsemble application.\n   *\n   * See [query]{@link RouterClientConstructor#query} for sending a corresponding query-event message to this responder.\n   *\n   * @param {string} channel any unique string to identify the channel (must match correspond query channel name); only one responder allower per channel\n   * @param {function} queryEventHandler function to handle the incoming query (see example below); note incoming queryMessage contains function to send response\n   * @example\n   *\n   * FSBL.Clients.RouterClient.addResponder(\"ResponderChannelName\", function (error, queryMessage) {\n   *\tif (error) {\n   *\t\t//console.log('addResponder failed: ' + JSON.stringify(error));\n   *\t} else {\n   *\t//console.log(\"incoming data=\" + queryMessage.data);\n   * \tvar response=\"Back at ya\"; // Responses can be objects or strings\n   *\tqueryMessage.sendQueryResponse(null, response); // A QUERY RESPONSE MUST BE SENT OR THE REMOTE SIDE WILL HANG\n   *\t}\n   * });\n   *\n   */\n\n\n  this.addResponder = function (channel, queryEventHandler) {\n    //console.log(\"RouterClient.addResponder\", \"CHANNEL\", channel); // Validate.args(channel, \"string\", queryEventHandler, \"function\");\n\n    var status = addResponderCallBack(mapResponders, channel, queryEventHandler);\n\n    if (status) {\n      sendToRouterService(new addResponderMessage(channel));\n    } else {\n      //console.log(\"RouterClient.addResponder: Responder already locally defined for channel \" + channel);\n      queryEventHandler({\n        \"RouteClient QueryError\": \"Responder already locally defined for channel\" + channel\n      }, null); // immediately invoke callback passing error\n    }\n  };\n  /**\n   * Send a query to responder listening on specified channel. The responder may be in this Finsemble window or another Finsemble window\n   *\n   * See [addResponder]{@link RouterClientConstructor#addResponder} to add a responder to receive the query.\n   *\n   * @param {string} responderChannel a unique string that identifies the channel (must match the channel name on which a responder is listening)\n   * @param {object} queryEvent event message sent to responder\n   * @param {any} params optional params\n   * @param {number} [params.timeout=20000]  timeout value for a query-response timer.  Timer defaults to 5000 milliseconds if no params value is passed in. Set timeout to zero to wait indefinitely. If the timer expires, this function call will return with an error.\n   * @param {function} responseEventHandler event handler to receive the query response (sent from a responder that is listening on this channel)\n   *\n   * @example\n   *\n   * FSBL.Clients.RouterClient.query(\"someChannelName\", {}, function (error, queryResponseMessage) {\n   *\tif (error) {\n   *\t\t//console.log('query failed: ' + JSON.stringify(error));\n   *\t} else {\n   *\t\t// process income query response message\n   *\t\tvar responseData = queryResponseMessage.data;\n   *\t\t//console.log('query response: ' + JSON.stringify(queryResponseMessage));\n   *\t}\n   * });\n   *\n   * FSBL.Clients.RouterClient.query(\"someChannelName\", { queryKey: \"abc123\"}, { timeout: 1000 }, function (error, queryResponseMessage) {\n   *\tif (!error) {\n   *\t\t// process income query response message\n   *\t\tvar responseData = queryResponseMessage.data;\n   *\t}\n   * }); */\n\n\n  this.query = function (responderChannel, queryEvent, params, responseEventHandler) {\n    if (responseEventHandler === void 0) {\n      responseEventHandler = Function.prototype;\n    }\n\n    var newQueryID = clientID() + \".\" + responderChannel; // var timestamp = window.performance.timing.navigationStart + window.performance.now();\n    // var navstart = window.performance.timing.navigationStart;\n    // var timenow = window.performance.now(); // these timer values used for logging diagnostics\n    // //console.log(\"RouterClient.query\", \"RESPONDER CHANNEL\", responderChannel, \"QUERY EVENT\", queryEvent, \"PARAMS\", params, \"QUERYID\", newQueryID, { timestamp, navstart, timenow });\n\n    if (arguments.length === 3) {\n      responseEventHandler = params;\n      params = {\n        timeout: 20000\n      };\n    }\n\n    params = params || {};\n\n    function promiseResolver(resolve) {\n      //Allows us to await on queries, cleaning up code quite a bit.\n      var modifiedHandler = function modifiedHandler(err, response) {\n        resolve({\n          err: err,\n          response: response\n        });\n        responseEventHandler(err, response);\n      };\n\n      addQueryResponseCallBack(mapQueryResponses, newQueryID, modifiedHandler);\n      addQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, responderChannel, params.timeout);\n      sendToRouterService(new QueryMessage(newQueryID, responderChannel, queryEvent));\n    }\n\n    return new Promise(promiseResolver);\n  };\n  /**\n   * Remove query responder from specified channel. Only a locally added responder can be removed (i.e. a responder defined in the same component or service).\n   *\n   * See [addResponder]{@link RouterClientConstructor#addResponder} for corresponding add of a query responder.\n   *\n   * @param {string} responderChannel string identifying the channel to remove responder from\n   *\n   * @example\n   *\n   * FSBL.Clients.RouterClient.removeResponder(\"someChannelName\");\n   *\n   */\n\n\n  this.removeResponder = function (responderChannel) {\n    //console.log(\"RouterClient.removeResponder\", \"RESPONDER CHANNEL\", responderChannel);\n    var status = removeResponderCallBack(mapResponders, responderChannel);\n\n    if (status) {\n      sendToRouterService(new RemoveResponderMessage(responderChannel));\n    }\n  };\n  /**\n   * Add a PubSub responder for specified topic. All subscribes and publishes to the topic will comes to responder (whether from local window or another window). Only one PubSub responder allowed per topic value in Finsemble application; however, the topic value may be a regular-expression representing a set of related topics, in which case the PubSub responder will responder to all matching topics. When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference is only one PubSub responder is needed to cover a set of related topics, plus the same callback handers can be used (if provided).\n   *\n   * All the callback function are optional because each PubSub responder comes with build-in default functionality (described below).\n   *\n   * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping RegEx topics.\n   *\n   * See [subscribe]{@link RouterClientConstructor#subscribe} and [publish]{@link RouterClientConstructor#publish} for corresponding functions sending to the PubSub responder.\n   *\n   * @param {string} topic unique topic for this responder, or a topic RegEx (e.g. '/abc.+/') to handle a set of topics\n   * @param {object} [initialState] initial state for the topic (defaults to empty struct); can be any object\n   * @param {object} [params] optional parameters\n   * @param {function} [params.subscribeCallback] allows responder know of incoming subscription and accept or reject it (default is to accept)\n   * @param {function} [params.publishCallback] allows responder to use the publish data to form a new state (default is the publish data becomes the new state)\n   * @param {function} [params.unsubscribeCallback] allows responder to know of the unsubscribe, but it must be accepted (the default accepts)\n   * @param {function} [callback] optional callback(err,res) function. If addPubSubResponder failed then err set; otherwise, res set to \"success\"\n   *\n   * @example\n   *\n   * function subscribeCallback(error, subscribe) {\n   * \tif (subscribe) {\n   * \t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\n   * \t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\n   * \t}\n   * }\n   * function publishCallback(error, publish) {\n   * \tif (publish) {\n   * \t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\n   * \t\tpublish.sendNotifyToAllSubscribers(null, publish.data);\n   * \t}\n   * }\n   * function unsubscribeCallback(error, unsubscribe) {\n   * \tif (unsubscribe) {\n   * \t\t// must make this callback to acknowledge the unsubscribe\n   * \t\tunsubscribe.removeSubscriber();\n   * \t}\n   * }\n   * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" },\n   * \t{\n   * \t\tsubscribeCallback:subscribeCallback,\n   * \t\tpublishCallback:publishCallback,\n   * \t\tunsubscribeCallback:unsubscribeCallback\n   * \t});\n   *\n   *   or\n   *\n   * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" });\n   *\n   *   or\n   *\n   * FSBL.Clients.RouterClient.addPubSubResponder(\\/topicA*\\/, { \"State\": \"start\" });\n   *\n   */\n\n\n  this.addPubSubResponder = function (topic, initialState, params, callback) {\n    var error;\n    var response;\n    //console.log(\"RouterClient.addPubSubResponder\", \"TOPIC\", topic, \"INITIAL STATE\", initialState, \"PARAMS\", params);\n    params = params || {};\n    var status = addPubSubResponderCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\n\n    if (status) {\n      initialState = initialState || {};\n      mapPubSubResponderState[topic.toString()] = clone(initialState, null);\n      sendToRouterService(new AddPubSubResponderMessage(topic.toString()));\n      response = \"success\";\n    } else {\n      error = \"RouterClient.addPubSubResponder: Responder already locally defined for topic \" + topic;\n      //console.log(error);\n    }\n\n    if (callback) {\n      callback(error, response);\n    }\n  };\n  /**\n   * Remove pubsub responder from specified topic. Only locally created responders (i.e. created in local window) can be removed.\n   *\n   * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder.\n   *\n   * @param {string} topic unique topic for responder being removed (may be RegEx, but if so much be exact regEx used previously with addPubSubResponder)\n   *\n   * @example\n   *\n   * FSBL.Clients.RouterClient.removePubSubResponder(\"topicABC\");\n   *\n   */\n\n\n  this.removePubSubResponder = function (topic) {\n    //console.log(\"RouterClient.removePubSubResponder\", \"TOPIC\", topic);\n    var status = removeResponderCallBack(mapPubSubResponders, topic);\n\n    if (status) {\n      delete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\n      delete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n\n      sendToRouterService(new RemovePubSubResponderMessage(topic));\n    } else {\n      //console.log(\"RouterClient.removePubSubResponder failed: Could not find responder for topic \" + topic);\n    }\n  };\n  /**\n   * Subscribe to a PubSub Responder. Each responder topic can have many subscribers (local in this window or remote in other windows). Each subscriber immediately (but asyncronouly) receives back current state in a notify; new notifys are receive for each publish sent to the same topic.\n   *\n   * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the subscribe. See [publish]{@link RouterClientConstructor#publish} for corresponding publish to notify the subscriber.\n   *\n   * @param {string} topic topic being subscribed to\n   * @param {function} notifyCallback invoked for each income notify for the given topic (i.e. initial notify plus for each publish)\n   * @returns {object} subscribe-id optionally used for unsubscribing later\n   *\n   * @example\n   *\n   * var subscribeId = RouterClient.subscribe(\"topicABC\", function(err,notify) {\n   *\t\tif (!err) {\n   *\t\t\tvar notificationStateData = notify.data;\n   *\t\t\t// do something with notify data\n   *  \t}\n   * });\n   *\n   */\n\n\n  this.subscribe = function (topic, notifyCallback) {\n    //console.log(\"RouterClient.subscribe\", \"TOPIC\", topic);\n    var subscribeID = clientID();\n    addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\n    sendToRouterService(new SubscribeMessage(subscribeID, topic));\n    return {\n      \"subscribeID\": subscribeID,\n      \"topic\": topic\n    };\n  };\n  /**\n   * Publish to a PubSub Responder, which will trigger a corresponding Notify to be sent to all subscribers (local in this window or remote in other windows). There can be multiple publishers for a topic (again, in same window or remote windows)\n   *\n   * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the publish (i.e. sending notifications to all subscriber). See [Subscribe]{@link RouterClientConstructor#addPubSubResponder} for corresponding subscription to receive publish results (in the form of a notify event)\n   *\n   * @param {string} topic topic being published to\n   * @param {object} event topic state to be published to all subscriber (unless the SubPub responder optionally modifies in between)\n   *\n   * @example\n   *\n   * FSBL.Clients.RouterClient.publish(\"topicABC\", topicState);\n   *\n   */\n\n\n  this.publish = function (topic, event) {\n    //console.log(\"RouterClient.publish\", \"TOPIC\", topic, \"EVENT\", event);\n    sendToRouterService(new PublishMessage(topic, event));\n  };\n  /**\n   * Unsubscribe from PubSub responder so no more notifications received (but doesn't affect other subscriptions). Only works from the window the PubSub responder was created in.\n   *\n   * See [subscribe]{@link RouterClientConstructor#subscribe} for corresponding subscription being removed.\n   *\n   * @param {object} subscribeID the id return from the corresponding subscribe for the topic\n   *\n   * @example\n   *\n   * FSBL.Clients.RouterClient.unsubscribe(subscribeId);\n   *\n   */\n\n\n  this.unsubscribe = function (subscribeIDStruct) {\n    //console.log(\"RouterClient.unsubscribe\", \"SUBSCRIBE ID\", subscribeIDStruct);\n    var deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\n\n    if (deletedSubscriber) {\n      sendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\n    } else {\n      //console.log(\"RouterClient.unsubscribe: Could not find subscribeID for topic \" + subscribeIDStruct.topic);\n    }\n  };\n  /**\n   * Test an incoming router message to see if it originated from the same origin (e.g. a trusted source...not cross-domain). Currently same origin is known only because a sharedWorker transport is used (by definition SharedWorkers do not work cross-domain).  This means any message coming in over the Inter-application Bus will not be trusted; however, by default all same-origin components and services connect to the router using a SharedWorker transport.\n   * @param {object} incomingMessage an incoming router message (e.g. transmit, query, notification) to test to see if trusted.\n   *\n   * @example\n   * FSBL.Clients.RouterClient.trustedMessage(incomingRouterMessage);\n   */\n\n\n  this.trustedMessage = function (incomingMessage) {\n    var isTrusted = true; // temporarily make all trusted so no problems if changing router transport\n\n    //console.log(\"RouterClient.trustedMessage header\", incomingMessage.header);\n\n    if (incomingMessage.header.originIncomingTransportInfo.transportID === \"SharedWorker\") {\n      isTrusted = true;\n    }\n\n    return isTrusted;\n  };\n  /**\n   * Removes all listeners, responders, and subscribers for this router client -- automatically called when client is shutting down. Can be called multiple times.\n   */\n\n\n  this.disconnectAll = function () {\n    //console.log(\"RouterClient.disconnectAll\");\n\n    for (var channel in mapListeners) {\n      //console.log(\"RouterClient.disconnectAll is removing listener on \" + channel);\n      sendToRouterService(new RemoveListenerMessage(channel));\n      delete mapListeners[channel];\n    }\n\n    for (var responderChannel in mapResponders) {\n      //console.log(\"RouterClient.disconnectAll is removing responder on \" + responderChannel);\n      sendToRouterService(new RemoveResponderMessage(responderChannel));\n      delete mapResponders[responderChannel];\n    }\n\n    for (var topic in mapPubSubResponders) {\n      //console.log(\"RouterClient.disconnectAll is removing pubsub responder on \" + topic);\n      sendToRouterService(new RemovePubSubResponderMessage(topic));\n      delete mapPubSubResponders[topic.toString()]; // could be a RegEx\n\n      delete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\n      delete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n    }\n\n    for (var subscribeID in mapSubscribersID) {\n      var stopic = mapSubscribersTopic[subscribeID];\n      //console.log(\"RouterClient.disconnectAll is removing subscriber on \" + stopic);\n      sendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\n      delete mapSubscribersID[subscribeID];\n      delete mapSubscribersTopic[subscribeID];\n    }\n  };\n\n  clientName = baseClientName;\n  constructor(clientName, \"FinsembleTransport\"); // constructor new router client\n\n  return this;\n};\n\n/***/ }),\n\n/***/ \"./routerClient/routerClientInstance.js\":\n/*!**********************************************!*\\\n  !*** ./routerClient/routerClientInstance.js ***!\n  \\**********************************************/\n/*! exports provided: router */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"router\", function() { return RouterClientInstance; });\n\n/*!\n * Copyright 2017 by ChartIQ, Inc.\n * All rights reserved.\n */\n// ? Had to remove because exports was not defined, not sure why I had to do this.\n// exports.__esModule = true;\n\n/**\n * @introduction\n * <h2>Router Client Instance</h2>\n * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\n *\n * Example:\n *\n *\t// get a shared instance of RouterClient (shared within the containing component or service)\n *\tvar RouterClient = require('./routerClientInstance').default;\n *\n * @namespace routerClientInstance\n * @shouldBePublished false\n */\n\nvar routerClientConstructor_1 = __webpack_require__(/*! ./routerClientConstructor */ \"./routerClient/routerClientConstructor.js\");\n\nvar RCConstructor = routerClientConstructor_1.RouterClientConstructor;\n/** An instance of the IRouterClient interface, (that is, the Router Client).\n * All other clients are built on top of the RouterClient; its API is the\n * primary form of communication between the various components of Finsemble.\n */\n\nvar RouterClientInstance = new RCConstructor({\n  clientName: \"RouterClient\"\n});\n // exports[\"default\"] = RouterClientInstance;\n\n/***/ }),\n\n/***/ \"./routerClient/routerTransport.js\":\n/*!*****************************************!*\\\n  !*** ./routerClient/routerTransport.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*! WSS://Chartiq.com\n * Copyright 2017 by ChartIQ, Inc.\n * All rights reserved.\n */\n// This routerTransport module is shared between router clients and the router service.  It supports\n// the addition of new transports without any change to the router code. Each transport is\n// point-to-point between a router client and the router service (i.e. hub and spoke).  Each router\n// client can use a different transport (i.e. the router service connects to them all).\n\n\nexports.__esModule = true; // var WebSocket = require(\"ws\");\n\n/**\n * @introduction\n * <h2>Router Transport</h2>\n * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e., Layer 2) supported by Finsemble.\n * Each transport communicates between a Finsemble services or component (i.e. a router client on one end) and the Finsemble router service (another router client on the other end).\n *\n * Integration into routerService.js is automatic on startup.\n *\n * Developer Notes on Adding New Transport:\n * 1) Create new transport constructor.\n * 2) Call RouterTransport.addTransport() to make the transport constructor (see the bottom of this file)\n *\n * Each transport constructor must be implemented with the following interface:\n *\n *\tExampleTransportConstructor(params, parentMessageHandler, source, destination) where\n *\n * \t\t\tparams is a passed in object including data that may (or may not) be needed for implementing the transport\n * \t\t\t\t\tparams.FinsembleUUID: globally unique identifier for Finsemble (one per host machine)\n *\t\t\t\t\tparams.applicationRoot:  value of manifest.finsemble.applicationRoot,\n *\t\t\t\t\tparams.routerDomainRoot: value of manifest.finsemble.moduleRoot,\n *\t\t\t\t\tparams.sameDomainTransport: transport to use for same domain clients\n *\t\t\t\t\tparams.crossDomainTransport: transport to use for cross domain clients\n *\t\t\t\t\tparams.transportSettings: transport settings from finsemble.router.transportSettings if defined, otherwise an empty object\n *\n * \t\t\tparentMessageHandler(incomingTransportInfo, routerMessage) where\n * \t\t\t\t\tincomingTransportInfo is a transport-specific object containing essential information to route back to the same client.\n * \t\t\t\t\t\tThe same object will be returned on a send() so the transport can use to send the message to that client.\n * \t\t\t\t\t\tIt's up to the developer to decide what to put in the incomingTransportInfo object. The RouterService never\n * \t\t\t\t\t\tdirectly uses the object, except to do a property-based comparison for equality (so equality must be based on the top-level properties within the object.)\n * \t\t\t\t\trouterMessage is an object containing a single router message. The transport generally does not need to know the contents --\n * \t\t\t\t\t\tit only sends and receives these messages. However, the router's header (routerMessage.header) is available to the transport if needed.\n *\n * \t\t\tsource is either the source's client name or \"RouterService\" (when the RouterService is the source)\n *\n * \t\t\tdestination is either the destination's client name or \"RouterService\" (when the RouterService is the desgination)\n *\n * \t\t\tcallback(this) returns the constructor.  Normally a constructor is not asyncronous, but support in case the constructed transport requires async initialization.\n *\n * The transport constructor must implement two functions.\n * \t\t1) send(transport, routerMessage) -- transport object contains destination transport info; routerMessage is the message to send\n * \t\t2) identifier() -- returns transport's name\n *\n * These functions along with the parentMessageHandler callback all that's needed to interface with the higher-level router (either a client or router service):\n *\n * The three transports implemented at the bottom of this file can serve as examples.\n *\n * @namespace RouterTransport\n */\n\nvar RouterTransport = {\n  activeTransports: {},\n\n  /**\n   * Adds a new type of router transport to pass message between RouterClient and RouterService.\n   *\n   * @param {string} transportName identifies the new transport\n   * @param {object} transportConstructor returns an instance of the new transport\n   */\n  addTransport: function addTransport(transportName, transportConstructor) {\n    this.activeTransports[transportName] = transportConstructor;\n    //console.log(\"RouterTransport \" + transportName + \" added to activeTransports\");\n  },\n\n  /**\n   * Gets array of active transports.  What is active depends both on config and what is supported by the environment. Typically, if OF IAB is defined then the IAB transport is added to active list.  Likewise, if SharedWorker defined, then SharedWork transport added to the active list.  Special transports that don't have backwards compatability (e.g. FinsembleTransport) are only added if specified in the config.\n   *\n   * @param {string} params transport paramters\n   *\n   * @returns array of active transport names\n   */\n  getActiveTransports: function getActiveTransports(params) {\n    var transportNames = []; // convenience funciton to add transport to active list only if it's not already in the list\n\n    function addToActive(transportName) {\n      if (transportNames.indexOf(transportName) === -1) {\n        // if not already in the list, then add it\n        transportNames.push(transportName);\n      }\n    } // add whatever the sameDomainTrasnport is to the active list\n\n\n    addToActive(params.sameDomainTransport); // add whatever the crossDomainTrasnport is to the active list\n\n    addToActive(params.crossDomainTransport);\n    //console.log(\"getActiveTransports\", transportNames);\n    return transportNames;\n  },\n\n  /**\n   * Get default transport for event router&mdash;this is the most reliable transport across all contexts.\n   *\n   * @param {object} params parameters for transport\n   * @param {any} incomingMessageHandler\n   * @param {any} source\n   * @param {any} destination\n   * @returns the transport object\n   */\n  getDefaultTransport: function getDefaultTransport(params, incomingMessageHandler, source, destination) {\n    return RouterTransport.getTransport(params, \"FinsembleTransport\", incomingMessageHandler, source, destination);\n  },\n\n  /**\n   * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.\n   *\n   * @param {object} params parameters for transport\n   * @param {any} incomingMessageHandler\n   * @param {any} source\n   * @param {any} destination\n   * @returns the transport object\n   */\n  getRecommendedTransport: function getRecommendedTransport(params, incomingMessageHandler, source, destination) {\n    return RouterTransport.getDefaultTransport(params, incomingMessageHandler, source, destination);\n  },\n\n  /**\n   * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\n   *\n   * @param {object} params parameters for transport\n   * @param {any} transportName\n   * @param {any} incomingMessageHandler\n   * @param {any} source\n   * @param {any} destination\n   * @returns the transport object\n   */\n  getTransport: function getTransport(params, transportName, incomingMessageHandler, source, destination) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      var transportConstructor = self.activeTransports[transportName];\n\n      if (transportConstructor) {\n        new transportConstructor(params, incomingMessageHandler, source, destination, function (newTransport) {\n          resolve(newTransport); //Set me to just return the correct transport.\n        });\n      } else {\n        reject(\"unknown router transport name: \" + transportName);\n      }\n    });\n  }\n}; //////////////////////////////////////////////////////////////\n// Below all transports are defined then added to active list\n//////////////////////////////////////////////////////////////\n\nvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\n\nfunction getDefault(base, path, defaultValue) {\n  var result = defaultValue;\n\n  if (base) {\n    try {\n      var properties = path.split(\".\");\n      var currentValue = base;\n\n      for (var i = 1; i < properties.length; i++) {\n        currentValue = currentValue[properties[i]];\n      }\n\n      result = currentValue;\n    } catch (err) {\n      result = defaultValue;\n    }\n\n    if (typeof result === \"undefined\") result = defaultValue;\n  }\n\n  return result;\n}\n/*\n * Implements the FinsembleTransport (alternative to IAB without iFrame problems with supporting server commonly running on local server).\n *\n * Required Functions (used by transport clients):\n * \t\tsend(event) -- transports the event\n * \t\tidentifier() -- returns transport name/identifier\n *\n * @param {object} params various parms to support transports\n * @param {any} parentMessageHandler callback for incoming event\n * @param {any} source either the client name or \"RouterService\"\n * @param {any} destination either the client name or \"RouterService\" (unused in FinsembleTransport)\n */\n//\n\n\nRouterTransportImplementation.FinsembleTransport = function (params, parentMessageHandler, source, destination, callback) {\n  /** @TODO - split into two separate vars for clarity. */\n  var serverAddress = getDefault(params, \"params.transportSettings.FinsembleTransport.serverAddress\", getDefault(params, \"params.transportSettings.FinsembleTransport.serverAddress\", \"ws://127.0.0.1:3376\"));\n  var SOCKET_SERVER_ADDRESS = serverAddress + \"/router\"; // \"router\" is the socket namespace used on server\n\n  var self = this; // receives incoming messages then passes on to parent (what's passed to parent should be same routerMessage received in send()\n\n  function finsembleMessageHandler(routerMessage) {\n    var incomingTransportInfo = {\n      transportID: self.identifier(),\n      client: routerMessage.clientMessage.header.origin\n    };\n    //console.log(\"FinsembleTransport Incoming Transport\", incomingTransportInfo, \"Message\", routerMessage);\n    parentMessageHandler(incomingTransportInfo, routerMessage.clientMessage);\n  } //required function for the parent (i.e. routeClient or routeService)\n\n\n  this.send = function (transport, routerMessage) {\n    var dest;\n    var message; // decide how to route the message based on whether client or routerservice is sending\n\n    if (arguments.length === 1) {\n      // clients use just one parameter, so send client message to RouterService\n      dest = \"ROUTER_SERVICE\";\n      routerMessage = arguments[0];\n      message = {\n        clientMessage: routerMessage\n      }; // no client property needed to route on server since always going to router service\n    } else {\n      // router service uses both parameters, so send router-service mssage to a client\n      dest = \"ROUTER_CLIENT\";\n      routerMessage = arguments[1];\n      message = {\n        client: transport.client,\n        clientMessage: routerMessage\n      }; // client property used to router on server\n    }\n\n    //console.log(\"FinsembleTransport Outgoing Transport\", dest, \"NewMessage\", message);\n    routerServerSocket.send(JSON.stringify({\n      dest: dest,\n      message: message\n    }));\n  }; //required function for the parent (i.e. routeClient or routeService)\n\n\n  this.identifier = function () {\n    return \"FinsembleTransport\";\n  };\n\n  //console.log(\"FinsembleTransport Transport Initializing for \" + source + \" using \" + SOCKET_SERVER_ADDRESS);\n\n  function connectTimeoutHandler() {\n    //console.log(\"FinsembleTransport Connection Timeout for \" + source);\n    callback(self);\n  } // set up for receiving incoming messages\n\n\n  var createSocketConn = function createSocketConn() {\n    var tempSocket;\n\n    if (SOCKET_SERVER_ADDRESS.startsWith(\"ws:\") || SOCKET_SERVER_ADDRESS.startsWith(\"wss:\")) {\n      tempSocket = new WebSocket(SOCKET_SERVER_ADDRESS);\n    } else {\n      console.error(\"address \".concat(SOCKET_SERVER_ADDRESS, \" is not a valid websocket protocol. Please use ws:// or wss://\"));\n    }\n\n    var connectTimer = setTimeout(connectTimeoutHandler, 3000); // cleared in setServiceOnline\n\n    tempSocket.addEventListener(\"open\", function () {\n      clearTimeout(connectTimer);\n      //console.log(\"FinsembleTransport Connected to Server\"); // TODO: Currently all messages are broadcast to everyone and filtering happens here. Need to implement a system similar to socket.io to prevent this or only send messages to proper destinations.\n\n      tempSocket.addEventListener(\"message\", function (event) {\n        var data = JSON.parse(event.data);\n\n        if (source === \"RouterService\" && data.dest == \"ROUTER_SERVICE\") {\n          finsembleMessageHandler(data.message);\n        } else if (source === data.message.client) {\n          finsembleMessageHandler(data.message);\n        }\n      });\n      callback(self);\n    });\n\n    tempSocket.onclose = function (e) {\n      //console.log('Socket is closed. Reconnect will be attempted in 1 second.');\n      setTimeout(function () {\n        routerServerSocket = createSocketConn();\n      }, 1000);\n    };\n\n    tempSocket.onerror = function (err) {\n      console.error('Socket error, closing socket', err);\n      tempSocket.close();\n    };\n\n    return tempSocket;\n  };\n\n  var routerServerSocket = createSocketConn();\n}; // add the transports to the available/active list\n\n\nRouterTransport.addTransport(\"FinsembleTransport\", RouterTransportImplementation.FinsembleTransport);\nexports[\"default\"] = RouterTransport;\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=fpe-router.map.js","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global global, Office, self, window */\n\nimport FpeRouter from \"@chartiq/fpe-router\";\n\nconst finsembleRouter = FpeRouter.router;\nconst LauncherClient = FpeRouter.LauncherClient;\nconst launcherClient = new LauncherClient(finsembleRouter);\nvar fileName = ''\nOffice.onReady(() => {\n  // If needed, Office.js is ready to be called\n  Office.context.document.settings.set(\"finsemble-excel\", true);\n  Office.context.document.settings.set(\"Office.AutoShowTaskpaneWithDocument\", true);\n  \n  //Office.addin.setStartupBehavior(Office.StartupBehavior.load)\n  Office.context.document.settings.saveAsync();\n\n  Office.context.document.getFilePropertiesAsync((asyncResult) => {\n    var fileUrl = asyncResult.value.url;\n    fileName = fileUrl.replace(/^.*[\\\\\\/]/, '')\n  })\n});\n\n/**\n * Shows a notification when the add-in command is executed.\n * @param event\n */\nconst action = (event: Office.AddinCommands.Event) => {\n  const message: Office.NotificationMessageDetails = {\n    type: Office.MailboxEnums.ItemNotificationMessageType.InformationalMessage,\n    message: \"Performed action.\",\n    icon: \"Icon.80x80\",\n    persistent: true\n  };\n\n  // Show a notification message\n  Office.context.mailbox.item.notificationMessages.replaceAsync(\"action\", message);\n\n  // Be sure to indicate when the add-in command function is complete\n  event.completed();\n};\n\nconst spawn = (event: Office.AddinCommands.Event) => {\n  launcherClient.Spawn(\"Welcome Component\");\n  event.completed();\n};\n\nconst broadcastData = (event: Office.AddinCommands.Event) => {\n  Excel.run(context => {\n    let worksheet = context.workbook.worksheets.getActiveWorksheet();\n    worksheet.load(\"items/name\");\n    let range = context.workbook.getSelectedRange();\n    range.load(\"address, values\");\n    return context.sync().then(() => {\n      finsembleRouter.transmit(`${fileName}-event`, {\n        event: \"SHEET_BROADCAST_VALUES\",\n        eventObj: {\n          worksheet: worksheet,\n          range: range.address.split(\"!\")[1],\n          values: range.values,\n          params: {value:\"test\"}\n        },\n        fileName: fileName\n      });\n      event.completed();\n    });\n  }).catch(console.log);\n};\n\nconst createBookmark = (event: Office.AddinCommands.Event) => {\n  Office.addin.showAsTaskpane().then(()=>{\n    finsembleRouter.transmit(`${fileName}-event`, { event: 'OPEN_CREATE_BOOKMARK_PANEL', fileName: fileName })\n    event.completed();\n  })\n};\n\nconst getGlobal = () => {\n  return typeof self !== \"undefined\"\n    ? self\n    : typeof window !== \"undefined\"\n    ? window\n    : typeof global !== \"undefined\"\n    ? global\n    : undefined;\n};\n\nconst g = getGlobal() as any;\n\n// the add-in command functions need to be available in global scope\ng.action = action;\ng.spawn = spawn;\ng.broadcastData = broadcastData;\ng.createBookmark = createBookmark;\n"],"sourceRoot":""}